## Overview 

Flow: https://miro.com/app/board/uXjVMXyfa-o=/?moveToWidget=3458764557412142387&cot=14


#### New Variables
```javascript
// create a mapping of IdentityId to application status
struct Application {
    address identityId;
    address recipientAddress;
    ApplicationStatus status;
    MetaPtr metaPtr;
}

// create a mapping of applicationId to application status
mapping(address => Application) applications;

// payouts data which will be set using setPayouts
struct Payout {
    address recipientAddress;
    uint32 percentage;
}

Payouts[] public payouts;
```

#### New Functions

Functions around updating constructor arguments.

```javascript
function updateVotingStart(uint64 _votingStart) external {}
function updateVotingEnd(uint64 _votingEnd) external {}
function updateApplicationStart(uint64 _applicationStart) external {}
function updateApplicationEnd(uint64 _applicationEnd) external {}
```

Functions around actual functionality

```javascript
function reviewApplications(bytes[] memory _data) external {
    // decode data to get identity id and status
    // update application status
}

function setPayouts(bytes memory _data) external isPoolOwner(){
    // TODO: discuss if this should be on distribution strategy
    // populate payouts array
    // would be invoked by pool owner for off-chain logic
}
```


### Open Questions

- How do we new add application status (like reapplied)
- Would it makes sense to have setPayouts on DistributionStrategy and generatePayout returns nothing ?

## Variations

The allocation strategy can be customized for different usecase

- Application Gating 
    - update initialize() (if applicable)
    - update applyToPool to invoke contracts to check gating
- Allocation Gating
    - update initialize() (if applicable)
    - update allocate to invoke contracts to check gating
- Not using registry. AKA no indentityId 
    - in these cases, an applicationID would have to be generated by the AllocationStrategy